let mapleader = " "

set hidden
set wildmenu
set wildmode+=longest,full
set ignorecase
set smartcase
set backspace=indent,eol,start
set nostartofline
set confirm
set mouse=a
set breakindent
set linebreak
set tabstop=8
set softtabstop=8
set autoindent
set shiftwidth=8
set undofile
set incsearch
set nomodeline
"set list
set lcs=nbsp:␣,eol:↲,tab:»\ ,trail:·,extends:›,precedes:‹,space:·
set foldlevelstart=20
set undofile
set completeopt=menu,menuone,preview,noselect,noinsert
set path+=**
set nrformats+=alpha
set guioptions+=k
set dictionary+=/usr/share/dict/words
set hlsearch
" set number
" set relativenumber
" set termguicolors

if has('nvim') || (v:version == 802 && has('patch4325')) || v:version > 802
  set wildoptions+=pum
endif

filetype plugin indent on

silent execute '!mkdir -p $HOME/.vim/backupdir/ $HOME/.vim/swp/ $HOME/.vim/undodir/'

" Double tailing slash stores files using full paths to avoid file name clashes
set backupdir=$HOME/.vim/backupdir//
set directory=$HOME/.vim/swp//
set undodir=$HOME/.vim/undodir//
set undofile

autocmd FileType gitcommit set textwidth=72
autocmd FileType gitcommit set colorcolumn=73

" Fix for slow startup time on Tmux
call serverlist()

" Git grep to quickfix list
command -nargs=+ Ggr execute 'Ggrep! -q' <q-args>

nnoremap <Up> :resize -2<CR>
nnoremap <Down> :resize +2<CR>
nnoremap <Left> :vertical resize -2<CR>
nnoremap <Right> :vertical resize +2<CR>
noremap <F6> :set list!<CR>
inoremap <F6> <C-o>:set list!<CR>
cnoremap <F6> <C-c>:set list!<CR>
syntax off

" obsession.vim - Continuously updated session files
if exists("g:loaded_obsession") || v:version < 704 || &cp
  finish
endif
let g:loaded_obsession = 1

command! -bar -bang -complete=file -nargs=? Obsession
      \ execute s:dispatch(<bang>0, <q-args>)

function! s:dispatch(bang, file) abort
  let session = get(g:, 'this_obsession', v:this_session)
  try
    if a:bang && empty(a:file) && filereadable(session)
      echo 'Deleting session in '.fnamemodify(session, ':~:.')
      call delete(session)
      unlet! g:this_obsession
      return ''
    elseif empty(a:file) && exists('g:this_obsession')
      echo 'Pausing session in '.fnamemodify(session, ':~:.')
      unlet g:this_obsession
      return ''
    elseif empty(a:file) && !empty(session)
      let file = session
    elseif empty(a:file)
      let file = getcwd() . '/Session.vim'
    elseif isdirectory(a:file)
      let file = substitute(fnamemodify(expand(a:file), ':p'), '[\/]$', '', '')
            \ . '/Session.vim'
    else
      let file = fnamemodify(expand(a:file), ':p')
    endif
    if !a:bang
      \ && file !~# 'Session\.vim$'
      \ && filereadable(file)
      \ && getfsize(file) > 0
      \ && readfile(file, '', 1)[0] !=# 'let SessionLoad = 1'
      return 'mksession '.fnameescape(file)
    endif
    let g:this_obsession = file
    let error = s:persist()
    if empty(error)
      echo 'Tracking session in '.fnamemodify(file, ':~:.')
      let v:this_session = file
      return ''
    else
      return error
    endif
  finally
    let &l:readonly = &l:readonly
  endtry
endfunction

function! s:doautocmd_user(arg) abort
  if !exists('#User#' . a:arg)
    return ''
  else
    return 'doautocmd <nomodeline> User ' . fnameescape(a:arg)
  endif
endfunction

function! s:persist() abort
  if exists('g:SessionLoad')
    return ''
  endif
  let sessionoptions = &sessionoptions
  if exists('g:this_obsession')
    let tmp = g:this_obsession . '.' . getpid() . '.obsession~'
    try
      set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
      exe s:doautocmd_user('ObsessionPre')
      execute 'mksession!' fnameescape(tmp)
      let v:this_session = g:this_obsession
      let body = readfile(tmp)
      call insert(body, 'let g:this_session = v:this_session', -3)
      call insert(body, 'let g:this_obsession = v:this_session', -3)
      if type(get(g:, 'obsession_append')) == type([])
        for line in g:obsession_append
          call insert(body, line, -3)
        endfor
      endif
      call writefile(body, tmp)
      call rename(tmp, g:this_obsession)
      let g:this_session = g:this_obsession
      exe s:doautocmd_user('Obsession')
    catch /^Vim(mksession):E11:/
      return ''
    catch
      unlet g:this_obsession
      let &l:readonly = &l:readonly
      return 'echoerr '.string(v:exception)
    finally
      let &sessionoptions = sessionoptions
      call delete(tmp)
    endtry
  endif
  return ''
endfunction

function! ObsessionStatus(...) abort
  let args = copy(a:000)
  let numeric = !empty(v:this_session) + exists('g:this_obsession')
  if type(get(args, 0, '')) == type(0)
    if !remove(args, 0)
      return ''
    endif
  endif
  if empty(args)
    let args = ['[$]', '[S]']
  endif
  if len(args) == 1 && numeric == 1
    let fmt = args[0]
  else
    let fmt = get(args, 2-numeric, '')
  endif
  return substitute(fmt, '%s', get(['', 'Session', 'Obsession'], numeric), 'g')
endfunction

augroup obsession
  autocmd!
  autocmd VimLeavePre * exe s:persist()
  autocmd BufEnter *
        \ if !get(g:, 'obsession_no_bufenter') |
        \   exe s:persist() |
        \ endif
  autocmd User Flags call Hoist('global', 'ObsessionStatus')
augroup END
